# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T13:27:49+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, SecretStr, conint, constr


class Accept(RootModel[str]):
    root: str


class ActiveContextName(
    RootModel[constr(pattern=r'^([A-Za-z]_?)+$', min_length=1, max_length=100)]
):
    root: constr(pattern=r'^([A-Za-z]_?)+$', min_length=1, max_length=100)


class ActiveContextTimeToLiveInSeconds(RootModel[conint(ge=5, le=86400)]):
    root: conint(ge=5, le=86400)


class ActiveContextTurnsToLive(RootModel[conint(ge=1, le=20)]):
    root: conint(ge=1, le=20)


class ActiveContextsString(RootModel[SecretStr]):
    root: SecretStr


class AttributesString(RootModel[SecretStr]):
    root: SecretStr


class BadGatewayException(RootModel[Any]):
    root: Any


class BadRequestException(RootModel[Any]):
    root: Any


class BlobStream(RootModel[str]):
    root: str


class BotAlias(RootModel[str]):
    root: str


class BotName(RootModel[str]):
    root: str


class BotVersion(
    RootModel[constr(pattern=r'[0-9]+|\$LATEST', min_length=1, max_length=64)]
):
    root: constr(pattern=r'[0-9]+|\$LATEST', min_length=1, max_length=64)


class ButtonTextStringWithLength(RootModel[constr(min_length=1, max_length=15)]):
    root: constr(min_length=1, max_length=15)


class ButtonValueStringWithLength(RootModel[constr(min_length=1, max_length=1000)]):
    root: constr(min_length=1, max_length=1000)


class ConfirmationStatus(Enum):
    None_ = 'None'
    Confirmed = 'Confirmed'
    Denied = 'Denied'


class ConflictException(RootModel[Any]):
    root: Any


class ContentType(Enum):
    application_vnd_amazonaws_card_generic = 'application/vnd.amazonaws.card.generic'


class DeleteSessionRequest(BaseModel):
    pass


class DependencyFailedException(RootModel[Any]):
    root: Any


class DialogActionType(Enum):
    ElicitIntent = 'ElicitIntent'
    ConfirmIntent = 'ConfirmIntent'
    ElicitSlot = 'ElicitSlot'
    Close = 'Close'
    Delegate = 'Delegate'


class DialogState(Enum):
    ElicitIntent = 'ElicitIntent'
    ConfirmIntent = 'ConfirmIntent'
    ElicitSlot = 'ElicitSlot'
    Fulfilled = 'Fulfilled'
    ReadyForFulfillment = 'ReadyForFulfillment'
    Failed = 'Failed'


class Double(RootModel[float]):
    root: float


class FulfillmentState(Enum):
    Fulfilled = 'Fulfilled'
    Failed = 'Failed'
    ReadyForFulfillment = 'ReadyForFulfillment'


class GetSessionRequest(BaseModel):
    pass


class HttpContentType(RootModel[str]):
    root: str


class IntentConfidence(BaseModel):
    score: Optional[Double] = None


class IntentName(RootModel[str]):
    root: str


class IntentSummaryCheckpointLabel(
    RootModel[constr(pattern=r'[a-zA-Z0-9-]+', min_length=1, max_length=255)]
):
    root: constr(pattern=r'[a-zA-Z0-9-]+', min_length=1, max_length=255)


class InternalFailureException(RootModel[Any]):
    root: Any


class LimitExceededException(RootModel[Any]):
    root: Any


class LoopDetectedException(RootModel[Any]):
    root: Any


class MessageFormatType(Enum):
    PlainText = 'PlainText'
    CustomPayload = 'CustomPayload'
    SSML = 'SSML'
    Composite = 'Composite'


class NotAcceptableException(RootModel[Any]):
    root: Any


class NotFoundException(RootModel[Any]):
    root: Any


class ParameterName(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class PostContentRequest(BaseModel):
    inputStream: BlobStream


class PostContentResponse(BaseModel):
    audioStream: Optional[BlobStream] = None


class PutSessionResponse(BaseModel):
    audioStream: Optional[BlobStream] = None


class RequestTimeoutException(RootModel[Any]):
    root: Any


class SensitiveString(RootModel[SecretStr]):
    root: SecretStr


class SensitiveStringUnbounded(RootModel[SecretStr]):
    root: SecretStr


class SentimentLabel(RootModel[str]):
    root: str


class SentimentScore(RootModel[str]):
    root: str


class String(RootModel[str]):
    root: str


class StringMap(RootModel[Optional[Dict[str, String]]]):
    root: Optional[Dict[str, String]] = None


class StringUrlWithLength(RootModel[constr(min_length=1, max_length=2048)]):
    root: constr(min_length=1, max_length=2048)


class StringWithLength(RootModel[constr(min_length=1, max_length=80)]):
    root: constr(min_length=1, max_length=80)


class Text(RootModel[SecretStr]):
    root: SecretStr


class UnsupportedMediaTypeException(RootModel[Any]):
    root: Any


class UserId(
    RootModel[constr(pattern=r'[0-9a-zA-Z._:-]+', min_length=2, max_length=100)]
):
    root: constr(pattern=r'[0-9a-zA-Z._:-]+', min_length=2, max_length=100)


class BotBotNameAliasBotAliasUserUserIdContentContentTypePostRequest(BaseModel):
    inputStream: str = Field(
        ...,
        description='<p> User input in PCM or Opus audio format or text format as described in the <code>Content-Type</code> HTTP header. </p> <p>You can stream audio data to Amazon Lex or you can create a local buffer that captures all of the audio data before sending. In general, you get better performance if you stream audio data rather than buffering the data locally.</p>',
    )


class DialogAction1(BaseModel):
    fulfillmentState: Optional[FulfillmentState] = None
    intentName: Optional[IntentName] = None
    message: Optional[Text] = None
    messageFormat: Optional[MessageFormatType] = None
    slotToElicit: Optional[String] = None
    slots: Optional[StringMap] = None
    type: Optional[DialogActionType] = None


class ActiveContextParametersMap(RootModel[Optional[Dict[str, Text]]]):
    root: Optional[Dict[str, Text]] = None


class ActiveContextTimeToLive(BaseModel):
    timeToLiveInSeconds: Optional[ActiveContextTimeToLiveInSeconds] = None
    turnsToLive: Optional[ActiveContextTurnsToLive] = None


class Button(BaseModel):
    text: ButtonTextStringWithLength
    value: ButtonValueStringWithLength


class DeleteSessionResponse(BaseModel):
    botAlias: Optional[BotAlias] = None
    botName: Optional[BotName] = None
    sessionId: Optional[String] = None
    userId: Optional[UserId] = None


class DialogAction(BaseModel):
    fulfillmentState: Optional[FulfillmentState] = None
    intentName: Optional[IntentName] = None
    message: Optional[Text] = None
    messageFormat: Optional[MessageFormatType] = None
    slotToElicit: Optional[String] = None
    slots: Optional[StringMap] = None
    type: DialogActionType


class IntentSummary(BaseModel):
    checkpointLabel: Optional[IntentSummaryCheckpointLabel] = None
    confirmationStatus: Optional[ConfirmationStatus] = None
    dialogActionType: DialogActionType
    fulfillmentState: Optional[FulfillmentState] = None
    intentName: Optional[IntentName] = None
    slotToElicit: Optional[String] = None
    slots: Optional[StringMap] = None


class IntentSummaryList(RootModel[List[IntentSummary]]):
    root: List[IntentSummary] = Field(..., max_length=3, min_length=0)


class PredictedIntent(BaseModel):
    intentName: Optional[IntentName] = None
    nluIntentConfidence: Optional[IntentConfidence] = None
    slots: Optional[StringMap] = None


class SentimentResponse(BaseModel):
    sentimentLabel: Optional[SentimentLabel] = None
    sentimentScore: Optional[SentimentScore] = None


class ListOfButtons(RootModel[List[Button]]):
    root: List[Button] = Field(..., max_length=5, min_length=0)


class ActiveContext(BaseModel):
    name: ActiveContextName
    parameters: ActiveContextParametersMap
    timeToLive: ActiveContextTimeToLive


class ActiveContextsList(RootModel[List[ActiveContext]]):
    root: List[ActiveContext] = Field(..., max_length=20, min_length=0)


class GenericAttachment(BaseModel):
    attachmentLinkUrl: Optional[StringUrlWithLength] = None
    buttons: Optional[ListOfButtons] = None
    imageUrl: Optional[StringUrlWithLength] = None
    subTitle: Optional[StringWithLength] = None
    title: Optional[StringWithLength] = None


class GetSessionResponse(BaseModel):
    activeContexts: Optional[ActiveContextsList] = None
    dialogAction: Optional[DialogAction] = None
    recentIntentSummaryView: Optional[IntentSummaryList] = None
    sessionAttributes: Optional[StringMap] = None
    sessionId: Optional[String] = None


class IntentList(RootModel[List[PredictedIntent]]):
    root: List[PredictedIntent] = Field(..., max_length=4)


class PostTextRequest(BaseModel):
    activeContexts: Optional[ActiveContextsList] = None
    inputText: Text
    requestAttributes: Optional[StringMap] = None
    sessionAttributes: Optional[StringMap] = None


class PutSessionRequest(BaseModel):
    activeContexts: Optional[ActiveContextsList] = None
    dialogAction: Optional[DialogAction] = None
    recentIntentSummaryView: Optional[IntentSummaryList] = None
    sessionAttributes: Optional[StringMap] = None


class GenericAttachmentList(RootModel[List[GenericAttachment]]):
    root: List[GenericAttachment] = Field(..., max_length=10, min_length=0)


class BotBotNameAliasBotAliasUserUserIdSessionPostRequest(BaseModel):
    activeContexts: Optional[List[ActiveContext]] = Field(
        None,
        description="<p>A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request,</p> <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.</p>",
        max_length=20,
        min_length=0,
    )
    dialogAction: Optional[DialogAction1] = Field(
        None,
        description='Describes the next action that the bot should take in its interaction with the user and provides information about the context in which the action takes place. Use the <code>DialogAction</code> data type to set the interaction to a specific state, or to return the interaction to a previous state.',
    )
    recentIntentSummaryView: Optional[List[IntentSummary]] = Field(
        None,
        description='<p>A summary of the recent intents for the bot. You can use the intent summary view to set a checkpoint label on an intent and modify attributes of intents. You can also use it to remove or add intent summary objects to the list.</p> <p>An intent that you modify or add to the list must make sense for the bot. For example, the intent name must be valid for the bot. You must provide valid values for:</p> <ul> <li> <p> <code>intentName</code> </p> </li> <li> <p>slot names</p> </li> <li> <p> <code>slotToElict</code> </p> </li> </ul> <p>If you send the <code>recentIntentSummaryView</code> parameter in a <code>PutSession</code> request, the contents of the new summary view replaces the old summary view. For example, if a <code>GetSession</code> request returns three intents in the summary view and you call <code>PutSession</code> with one intent in the summary view, the next call to <code>GetSession</code> will only return one intent.</p>',
        max_length=3,
        min_length=0,
    )
    sessionAttributes: Optional[Dict[str, String]] = Field(
        None,
        description='Map of key/value pairs representing the session-specific context information. It contains application information passed between Amazon Lex and a client application.',
    )


class BotBotNameAliasBotAliasUserUserIdTextPostRequest(BaseModel):
    activeContexts: Optional[List[ActiveContext]] = Field(
        None,
        description="<p>A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request,</p> <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.</p>",
        max_length=20,
        min_length=0,
    )
    inputText: SecretStr = Field(
        ...,
        description='The text that the user entered (Amazon Lex interprets this text).',
    )
    requestAttributes: Optional[Dict[str, String]] = Field(
        None,
        description='<p>Request-specific information passed between Amazon Lex and a client application.</p> <p>The namespace <code>x-amz-lex:</code> is reserved for special attributes. Don\'t create any request attributes with the prefix <code>x-amz-lex:</code>.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs">Setting Request Attributes</a>.</p>',
    )
    sessionAttributes: Optional[Dict[str, String]] = Field(
        None,
        description='<p>Application-specific information passed between Amazon Lex and a client application.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs">Setting Session Attributes</a>.</p>',
    )


class ResponseCard(BaseModel):
    contentType: Optional[ContentType] = None
    genericAttachments: Optional[GenericAttachmentList] = None
    version: Optional[String] = None


class PostTextResponse(BaseModel):
    activeContexts: Optional[ActiveContextsList] = None
    alternativeIntents: Optional[IntentList] = None
    botVersion: Optional[BotVersion] = None
    dialogState: Optional[DialogState] = None
    intentName: Optional[IntentName] = None
    message: Optional[Text] = None
    messageFormat: Optional[MessageFormatType] = None
    nluIntentConfidence: Optional[IntentConfidence] = None
    responseCard: Optional[ResponseCard] = None
    sentimentResponse: Optional[SentimentResponse] = None
    sessionAttributes: Optional[StringMap] = None
    sessionId: Optional[String] = None
    slotToElicit: Optional[String] = None
    slots: Optional[StringMap] = None
